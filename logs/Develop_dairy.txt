2024年5月1日：
实现士兵检测前方方块是否可以行走功能
实现思路：在士兵第一次被放置或移动的时候调用scanChessBlock_canWalk()方法，该方法会返回一个包含了棋子可以移动到的格子的数组。
当士兵调用move方法的时候检测他要移动到的格子是否在这个数组中，如果没有就停止这次移动。

2024年5月2日：
实现棋子（士兵）和棋格可以被选中。且棋子可以判断自己是否可以移动到被选中的棋格那里（被选中的棋格上没有其他的棋子。同时距离士兵棋子
的距离不超过一个格子。）
实现思路：当被选中的棋格上有棋子时，将这个棋子加入到readyToMove数组中，当玩家再选中一个棋格，且棋子可以移动到这个棋格而且这个棋
格上没有任何棋子时，将棋子移动到这个被选中的棋格上。

2024年5月3日：
创建出BlackPlayer类，实现黑方和白方轮流下棋。

2024年5月5日：
实现了黑棋的移动功能。

2024年5月18日：
实现棋子的吃子功能。
实现思路：
1. 确定棋子攻击范围，将可以攻击的棋子加入到canAttack数组中(分为canAttack_W数组和canAttack_B数组)，
当棋子攻击时，遍历canAttack数组，确认被攻击的棋子是否在攻击范围内。
2.如果被选中的被攻击的棋子在攻击范围内，将被攻击的棋子加入到readyToAttack数组中(这个数组将在SoldiersMovement类中)
3. 当被选中的棋子攻击攻击范围内的被选中的棋子时，将攻击方棋子移动到被攻击方棋子上并消除被攻击方棋子的实例。
4.攻击完成后，清空canAttack数组和readyToAttack数组。

2024年5月25日：
继续实现2024年5月18日的棋子吃子功能。实现了scan_W_canAttack()方法同时提交一份备忘录。
备忘录：
可以尝试把SoldiersMovement类拆分为Soldiers_W_Movement类和Soldiers_B_Movement类，这样可以更好的实现代码的可读性和维护性。

2024年6月1日：
已经把SoldiersMovement类拆分为Soldiers_W_Movement类和Soldiers_B_Movement类，这样可以更好的实现代码的可读性和维护性。
备忘录：
下次可以尝试将SoldiersAttackBehaviors类拆分为Soldiers_W_AttackBehaviors类和Soldiers_B_AttackBehaviors类，
这样可以更好的实现代码的可读性和维护性。或者尝试实现scan_B_canAttack()方法

2024年6月8日：
已经将SoldiersAttackBehaviors类拆分为Soldiers_W_AttackBehaviors类和Soldiers_B_AttackBehaviors类，
这样可以更好的实现代码的可读性和维护性。同时实现了scan_B_canAttack()方法。

2024年6月9日：
做完了士兵的吃子功能。

2024年6月28日：
开始开发车的移动功能。写完了Cars_W_Movement类中的scan_W_ChessBlock_canWalk()方法。

2024年6月30日：
写完了Cars_W_Movement类

2024年7月1日：
写完了WhiteCar的攻击和移动功能。
更正：
写完了Car的所有行为。

2024年7月2日：
写完了白马的移动功能。

2024年7月3日：
写完了白马的攻击功能。

2024年7月4日：
写完了黑马的移动功能和攻击功能。

2024年7月5日：
写完了白象的移动功能和攻击功能。
更正：
写完了黑象和白象的所有行为。并修复了车和象隔空攻击的bug。

2024年7月6日：
写完了皇后的所有行为。
发现了一个bug。初步判断可能是因为被吃掉棋子的实例没有被正确删除导致的，这个bug有时候会发生，有时候不会发生。
注解：此次提交的版本可能会含有bug。所以测试代码将被保留。
更正：
十点零版本中提到的bug可能被修复了。但后续仍需要注意观察。

2024年7月7日：
对十点零版本中提到的bug再次尝试进行了修复。可能被修好了。

2024年7月8日：
写完了王的所有行为。(也就是写完了所有棋子的所有行为),移除了为修复十点零版本中提到的bug的测试代码。因为bug可能被修好了。

2024年7月9日：
写完了游戏的初始化器。

2024年7月10日：
增加了保存棋局的功能。

2024年7月11日：
优化了部分代码。